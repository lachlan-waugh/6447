<!doctype html><html lang=en><head><meta charset=utf-8><title>2: buffer overflows</title>
<meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="black-translucent"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><link rel=stylesheet href=../reveal-js/css/reset.css><link rel=stylesheet href=../reveal-js/css/reveal.css><link rel=stylesheet href=../reveal-js/css/theme/black.css id=theme><link rel=stylesheet href=../highlight-js/default.min.css></head><body><div class=reveal><div class=slides><section><h2 id=well-get-started-at-16805>We&rsquo;ll get started at 1[68]:05</h2></section><section data-noprocess data-shortcode-slide class=center><h1 id=buffer-overflowssssssssssssssssssssssssssssssssssssssssssssxefxebaded>buffer overflowssssssssssssssssssssssssssssssssssssssssssss\xef\xeb\ad\ed</h1><h3 id=6447-week2>6447 week2</h3></section><section><h2 id=good-faith-policy>Good faith policy</h2><p>We expect a high standard of professionalism from you at all times while you are taking any of our courses. We expect all students to act in good faith at all times</p><p><em>TLDR: Don&rsquo;t be a <del>dick</del> jerk</em></p><p><a href=https://sec.edu.au/good-faith-policy>sec.edu.au/good-faith-policy</a></p></section><section><h2 id=lecture-content>Lecture content</h2><ul><li>what is stack</li><li>buffer overflows</li><li>memory protections</li></ul></section><section><section data-shortcode-section><h2 id=register-layout>register layout</h2><ul><li>AX is the bottom half of EAX (AH/AL), not the top half</li></ul></section><section><h2 id=stack-frames>stack frames</h2><ul><li>what register stores the stack, and frame pointer?</li><li>why are the parameters stored <em>below</em> frame pointer?</li></ul></section><section><h2 id=the-stack-grows-sideways>the stack grows sideways</h2><p>jk it grows down</p><ul><li>the stack grows from high address to low addresses</li><li>so the top of the stack, is lower down in memory</li><li>this doesn&rsquo;t really change how you exploit, you also just write up the stack</li></ul></section><section><h2 id=stack-frames-1>stack frames</h2><p>basic example</p><pre tabindex=0><code>    0x18  [   ARGS   ] &lt;- parameters
    0x14  [   EIP    ] &lt;- stored return pointer
    0x10  [   EBP    ] &lt;- stored frame pointer
    0x0C  [ AAAAAAAA ] &lt;- local vars
    0x08  [ 00000001 ] &lt;- an int?
    0x04  [ DEADBEEF ] &lt;- a pointer
    0x00  [ 59454554 ] &lt;- 4 characters
</code></pre></section><section><h2 id=where-are-vars>where are vars</h2><p>referenced in relation to <code>ebp</code> e.g. <code>ebp-0x4</code></p><ul><li>local vars are <del>above</del> later, so <code>ebp-0x4</code></li><li>arguments are <del>below</del> earlier so <code>ebp-0x8</code></li></ul></section></section><section><section data-shortcode-section><h2 id=buffer-overflows>buffer overflows</h2><p>tldr: trust is bad</p></section><section><h3 id=reading-into-a-buffer>reading into a buffer</h3><p>what happens when you write more content than a buffer can hold</p><ul><li>mordern languages might just resize (python)</li><li>some languages might throw an exception</li><li>maybe it would crash? (sometimes it will)</li><li>C (& lower-level languages) just kinda run with it</li></ul></section><section><h3 id=overflowing>overflowing</h3><p>so where exactly does that content go</p><ul><li>we&rsquo;ve talked about stack frames</li><li>if we write more content, it&rsquo;ll just start overwriting other content on the stack<ul><li>other variables</li><li>control stuff (EBP, EIP)</li></ul></li></ul></section><section><h3 id=what-can-i-overwrite>what can I overwrite?</h3><ul><li>local variables</li><li>return addresses</li><li><del>content from other processes?</del></li></ul><blockquote><p>this could allow us to change the application flow</p></blockquote></section><section><h3 id=demo>demo</h3></section><section><h3 id=when-is-a-program-vulnerable>when is a program vulnerable</h3><p>what functions cause buffer overflows?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=nohighlight data-noescape><span style=display:flex><span><span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>32</span>] a;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// read content
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>gets</span>(a);
</span></span><span style=display:flex><span><span style=color:#a6e22e>fgets</span>(a, <span style=color:#ae81ff>0x32</span>, stdin)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// printf, but write to a string not stdout
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>sprintf</span>(a, <span style=color:#e6db74>&#34;%s %s %d&#34;</span>, some, random, vars);
</span></span><span style=display:flex><span><span style=color:#a6e22e>snprintf</span>(a, <span style=color:#e6db74>&#34;%s %s %d&#34;</span>, <span style=color:#ae81ff>0x32</span>, and, more, vars);
</span></span></code></pre></div></section><section><h3 id=but-thats-not-all>but that&rsquo;s not all</h3><p>it&rsquo;s not just reading content, but also copying?</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=nohighlight data-noescape><span style=display:flex><span><span style=color:#66d9ef>char</span> buffer[<span style=color:#ae81ff>32</span>] a, buffer[<span style=color:#ae81ff>64</span>] b;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// copy contents of b into a 
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>strcpy</span>(a, b);
</span></span><span style=display:flex><span><span style=color:#a6e22e>strncpy</span>(a, b, <span style=color:#ae81ff>64</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// append contents of b onto a
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>strcat</span>(a, b);
</span></span><span style=display:flex><span><span style=color:#a6e22e>strncat</span>(a, b, <span style=color:#a6e22e>strlen</span>(a) <span style=color:#f92672>+</span> <span style=color:#a6e22e>strlen</span>(b));
</span></span></code></pre></div></section></section><section><section data-shortcode-section><h2 id=how-do-i-find-offsets>how do I find offsets</h2></section><section><h3 id=binja>binja</h3><p>binja is really nice and tells us the distance</p><p><img src=../assets/img/week02/binja.png alt></p><ul><li>int is 0xC (12) bytes away from the return address</li><li>buffer is 0x34 (52) bytes away</li></ul><blockquote><p>if we wrote 40 bytes of padding, and one additional byte into the buffer, we would overwrite the int</p></blockquote></section><section><h3 id=cyclic>cyclic</h3><p>kinda like bruteforce but smart</p><ul><li>what if we gave a random string as input</li><li>then found what part of the string overwrote EIP</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=nohighlight data-noescape><span style=display:flex><span><span style=color:#75715e># gets(buffer)</span>
</span></span><span style=display:flex><span>$ AAAABBBBCCCCDDDDEEEEFFFF
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># we SIGSEGV at EIP = EEEE</span>
</span></span></code></pre></div><blockquote><p>then we need 16 bytes of padding before the return address</p></blockquote></section><section><h3 id=how-to-generate-random-strings>how to generate random strings</h3><p>pwntools</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=nohighlight data-noescape><span style=display:flex><span><span style=color:#75715e>#  </span>
</span></span><span style=display:flex><span>cyclic(<span style=color:#ae81ff>20</span>) <span style=color:#75715e># generate a chunk of length 20</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#   </span>
</span></span><span style=display:flex><span>c <span style=color:#f92672>=</span> cyclic_gen()
</span></span><span style=display:flex><span>c<span style=color:#f92672>.</span>get(n)        <span style=color:#75715e># get a chunk of length n</span>
</span></span><span style=display:flex><span>c<span style=color:#f92672>.</span>find(<span style=color:#e6db74>b</span><span style=color:#e6db74>&#39;caaa&#39;</span>) <span style=color:#75715e># (8,0,8): pos 8, which is chunk 0 at pos 8</span>
</span></span></code></pre></div><p>bash</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=nohighlight data-noescape><span style=display:flex><span><span style=color:#75715e># you can also do it on commandline</span>
</span></span><span style=display:flex><span>cyclic <span style=color:#ae81ff>12</span>      <span style=color:#75715e># aaaaaaabaaac</span>
</span></span><span style=display:flex><span>cyclic -l aaab <span style=color:#75715e># -&gt; 1  = find chunk</span>
</span></span><span style=display:flex><span>cyclic -o aaae <span style=color:#75715e># -&gt; 13 = find offset</span>
</span></span></code></pre></div></section></section><section><section data-shortcode-section><h1 id=memory-protections>memory protections</h1><p>ew cringe security stuff</p></section><section><h2 id=pie-yum>PIE (yum)</h2><p>position independent execution</p><ul><li>every time you run the binary, it gets loaded into a different location in memory</li><li>this means just can&rsquo;t simply set EIP to <code>win()</code></li><li>binja will only show the offset from the binary base</li></ul></section><section><h3 id=what-does-it-look-like>what does it look like</h3><p>notice the region is entirely different</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=nohighlight data-noescape><span style=display:flex><span><span style=color:#75715e># no PIE</span>
</span></span><span style=display:flex><span>$ ./leak
</span></span><span style=display:flex><span>win<span style=color:#f92672>()</span> is at 0x8041234
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># with PIE</span>
</span></span><span style=display:flex><span>$ ./leak
</span></span><span style=display:flex><span>win<span style=color:#f92672>()</span> is at 0x5650161
</span></span><span style=display:flex><span>$ ./leak
</span></span><span style=display:flex><span>win<span style=color:#f92672>()</span> is at 0x5650911
</span></span></code></pre></div></section><section><h2 id=aslr>ASLR</h2><p>address space layout randomization</p></section><section><h3 id=using-aslr>using ASLR</h3><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=nohighlight data-noescape><span style=display:flex><span><span style=color:#75715e># turn aslr off</span>
</span></span><span style=display:flex><span>sudo sysctl kernel.randomize_va_space<span style=color:#f92672>=</span><span style=color:#ae81ff>0</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># check if it&#39;s on</span>
</span></span><span style=display:flex><span>cat /proc/sys/kernel/randomize_va_space
</span></span></code></pre></div></section><section><h3 id=wait-whats-the-difference>wait what&rsquo;s the difference</h3><p>ASLR is a kernel protection, PIE is a binary protection</p><ul><li>aslr is kinda like PIE for libc</li></ul></section><section><h2 id=stack-canaries>stack canaries</h2><p>they save the day and make overflows impossible</p><ul><li>a random value between the user buffers and [ER]IP</li><li>if the value of that canary changes during execution, the program will abort</li><li>this is what the <code>__stack_chk_fail()</code> thing is in some of the source code you&rsquo;ll have read</li></ul></section><section><h3 id=canaries-in-memory>canaries in memory</h3><pre tabindex=0><code>    0x1C  [  ARGS  ] &lt;- parameters
    0x18  [   EIP  ] &lt;- stored return pointer
    0x14  [   EBP  ] &lt;- stored frame pointer
    0x00  [ canary ] &lt;- canary goes here
    0x0C  [  AAAA  ] &lt;- these are local vars
    0x08  [  AAAA  ]
    0x04  [  AAAA  ]
    0x00  [  AAAA  ]
</code></pre><blockquote><p>real value stored somewhere else, and checked before the function returns</p></blockquote></section><section><h3 id=how-do-i-defeat-them>how do I defeat them</h3><p>memory leaks basically</p><ul><li>PIE/ASLR: leak function pointer and you&rsquo;re good</li><li>canaries: leak the canary&rsquo;s value</li><li>the stack sometimes has some interesting values, but how can we leak them (this comes in week 4)</li></ul></section><section><h3 id=cool-notes>cool notes</h3><ul><li><a href=https://ir0nstone.gitbook.io/notes/types/stack/introduction>these could be helpful</a></li></ul></section></section><section><section data-shortcode-section><h2 id=lab>lab</h2><ul><li>there is one binary, with 2 vulns (both trivial)<ul><li>don&rsquo;t look at the source code</li><li>later on you won&rsquo;t be given it!</li></ul></li></ul><blockquote><p>give it a go in groups of 2!</p></blockquote></section><section><h1 id=walkthrough>walkthrough</h1></section></section></div></div><script type=text/javascript src=../reveal-hugo/object-assign.js></script><a href=../reveal-js/css/print/ id=print-location style=display:none></a><script type=text/javascript>var printLocationElement=document.getElementById("print-location"),link=document.createElement("link");link.rel="stylesheet",link.type="text/css",link.href=printLocationElement.href+(window.location.search.match(/print-pdf/gi)?"pdf.css":"paper.css"),document.getElementsByTagName("head")[0].appendChild(link)</script><script type=application/json id=reveal-hugo-site-params>null</script><script type=application/json id=reveal-hugo-page-params>null</script><script src=../reveal-js/js/reveal.js></script><script type=text/javascript>function camelize(e){return e&&Object.keys(e).forEach(function(t){newK=t.replace(/(_\w)/g,function(e){return e[1].toUpperCase()}),newK!=t&&(e[newK]=e[t],delete e[t])}),e}var revealHugoDefaults={center:!0,controls:!0,history:!0,progress:!0,transition:"slide"},revealHugoSiteParams=JSON.parse(document.getElementById("reveal-hugo-site-params").innerHTML),revealHugoPageParams=JSON.parse(document.getElementById("reveal-hugo-page-params").innerHTML),options=Object.assign({},camelize(revealHugoDefaults),camelize(revealHugoSiteParams),camelize(revealHugoPageParams));Reveal.initialize(options)</script><script type=text/javascript src=../reveal-js/plugin/markdown/marked.js></script><script type=text/javascript src=../reveal-js/plugin/markdown/markdown.js></script><script type=text/javascript src=../reveal-js/plugin/highlight/highlight.js></script><script type=text/javascript src=../reveal-js/plugin/zoom-js/zoom.js></script><script type=text/javascript src=../reveal-js/plugin/notes/notes.js></script></body></html>